---
layout: post
title: Java Floating-Point Operation
categories:
- JAVA
tags:
- Java
status: publish
type: post
published: true
meta: {}
author:
  login: villim
  email: villim@126.com
  display_name: Villim
  first_name: Villim
  last_name: Wong
---
<p>先看这个小程序会打印出什么值：</p>
<pre class="brush:java">package net.villim.www;
public class TestFloat {
	public static void main(String[] args) {
		System.out.println(2.0 - 1.1);
	}
}</pre>
<p>当然不会那么简单，绝对不可能是 <strong>0.9</strong> ！！实际打印出的值是 <strong>0.8999999999999999</strong> 确实让人大跌眼镜。发什么什么事情？<br />
---------------------有兴趣，请自己先想想------------------------------</p>
<h3><span style="color: #008000;">为什么不能正确得到 0.9 ？？</span></h3>
<p>这里的猫腻当然就是 <strong>System.out.println(2.0 - 1.1);</strong> 简简单单的 “2.0”和 “1.1” 有什么问题呢？</p>
<p>原因就是计算机无法准确的描述 “<strong>1.1</strong>” 这个值！ 我们知道计算机最终是用2进制来运算的。所以我们需要将 1.1 转化为二进制。</p>
<h4>十进制整数转二进制整数：</h4>
<p><span style="text-decoration: underline;"><em>采用"除2取余，逆序排列"法。具体做法是：用2去除十进制整数，可以得到一个商和余数；再用2去除商，又会得到一个商和余数，如此进行，直到商为一时为止，然后把先得到的余数作为二进制数的低位有效位，后得到的余数作为二进制数的高位有效位，依次排列起来。</em></span></p>
<h4>十进制小数转换成二进制小数：</h4>
<p><span style="text-decoration: underline;"><em>采用"乘2取整，顺序排列"法。具体做法是：用2乘十进制小数，可以得到积，将积的整数部分取出，再用2乘余下的小数部分，又得到一个积，再将积的整数部分取出，如此进行，直到积中的整数部分为零，或者整数部分为1，此时1位二进制的最后一位。或者达到所要求的精度为止。</em></span></p>
<p>所以，假如我们用 8 位来表示 “1.1” 可以得到 “<strong>0000 0001 . 00011001</strong>” . 我们再将二进制转为十进制，得到的是 “<strong>1.09765625</strong>” !! 就是说计算机只能得到最接近 1.1 的值。更准确的描述应该是，<span style="color: #800000;"><strong>不是所有的小数都能精确地用二进制浮点数表示</strong></span>。</p>
<p>所以当我们需要精确使用小数的时候，怎么办呢<strong>？ 应该使用 int， long 或者 BigDecimal ！<br />
</strong></p>
<p>使用 BigDecimal 的时候也要格外注意，<strong>应该使用 BigDecimal（String） 而不是 BigDecimal（double）</strong>！假如尝试打印 BigDecimal（0.1） 你将得到  0.1000000000000000055511151231257827021181583404541015625!!  Orz ~~</p>
<h3></h3>
<h3><span style="color: #008000;">快速转二进制为十进制</span></h3>
<p>比如 <strong>0.635</strong> ，如何判断需要多少位才能精确地表示它呢？</p>
<p>根据前面的转换规则其实我们可以推断出简单的方法： <strong>就用那个十进制乘以2的n次方，看小数部分是否为零，是的话就能用n位精确表示，否的话就不能。</strong> 比如，0.635*256=162.56。因为小数部分不为0，所以8位二进制小数无法精确表示。再看0.635*65536=41615.36。小数部分仍不为0，所以16位也不能精确表示。</p>
<p>如何快速转换呢？ 比如 52.63 ， 如果用8位表示小数部分，把0.63*256也就是2的8次方得到161.23，23不要，把161化成二进制表示为 10100001，再连上52的，就成了1010010.10100001。</p>
<p>&nbsp;</p>
<h3><span style="color: #008000;">这个问题还有一个引申的关注点，计算机是如何做这个减法的呢？</span></h3>
<p>这里有三个老概念，原码，补码和反码。以下用 X1 = + 1010 110 和 X2 = -1001010 来举例。</p>
<p><span style="color: #993300;"><strong>原码 （True Form）：</strong></span>其符号位用0表示正号，用1表示负号，数值一般用二进制形式表示。</p>
<p>［X1］原=[＋1010110]原=01010110  ［X2］原=[－1001010]原=11001010</p>
<p>在原码表示法中，对0有两种表示形式：<br />
［+0］原=00000000  [－0] 原=10000000</p>
<p><span style="color: #993300;"><strong>补码 （2's complement）：</strong></span> 补码可由原码得到。如果机器数是正数，则该机器数的补码与原码一样；如果机器数是负数，则该机器数的补码是对它的原码（除符号位外）各位取反，并在未位加1而得到的。</p>
<p>[X2] 原= 11001010  [X2] 补=10110101＋1＝10110110</p>
<p>在补码表示法中，0只有一种表示形式：<br />
[＋0]补=00000000  [＋0]补=11111111＋1=00000000（由于受设备字长的限制，最后的进位丢失）</p>
<p><span style="color: #993300;"><strong>反码 （1's complement）</strong>：</span> 反码可由原码得到。如果机器数是正数，则该机器数的反码与原码一样；如果机器数是负数，则该机器数的反码是对它的原码（符号位除外）各位取反而得到的。</p>
<p>[X1]反=［X1］原=01010110   [X2]反=10110101</p>
<p><strong>在计算机系统里，数值一律用补码来表示（存储）。</strong> 主要原因：使用补码，可以将符号位和其它位统一处理；同时，减法也可按加法来处理。另外，两个用补 码表示的数相加时，如果最高位（符号位）有进位，则进位被舍弃。</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
